Kapitel 5

Ein tiefer Einblick in Monero & Kryptographie

Schon lange vor der Geburt des Computers standen Mathematik und Kryptografie im Mittelpunkt der Kommunikation und des Informationsaustauschs. Während es einfache Chiffren schon seit Cäsars Zeiten gibt, wurde die moderne Kryptografie während der Weltkriege zur Verschlüsselung wichtiger und vertraulicher Nachrichten entwickelt. Ursprünglich finanzierten Regierungen und Militärs geheime Kryptographieforschung, um Protokolle zum Schutz von Staatsgeheimnissen zu entwickeln.

Heute ist die Kryptografie nicht mehr auf Spione und Militärs beschränkt; sie bildet das Rückgrat der Kommunikation und Sicherheit im Internetzeitalter und wird von Wissenschaftlern und Industrieforschern auf der ganzen Welt untersucht.

In der heutigen Zeit ist die Kryptografie ein allgegenwärtiges Werkzeug, das Sicherheit, Verwaltung, Kommunikation und viele der Verbindungen ermöglicht, die unser tägliches Leben verbessern. Denken Sie zum Beispiel an die Erfindung von Secure Socket Layer (SSL, veraltet zugunsten von TLS), das auf der kryptografischen Signierung von Inhalten beruht. Krankenhäuser, Banken, Regierungen und Unternehmen schützen ihre Daten mit Kryptografie.

In diesem Kapitel wird erörtert, wie kryptografische Werkzeuge auf eine dezentralisierte Finanzdatenbank angewendet werden können, um Kryptowährungen, insbesondere Monero, entstehen zu lassen.

5.1 Mathematische Grundlagen

Hier ist eine kurze Einführung/Rekapitulation einiger mathematischer Prinzipien, die den Kern der Kryptographie bilden.

5.1.1 Euklidische Division (A/B)

Die Division einer beliebigen Zahl A durch eine andere B, geschrieben als A/B oder A÷B, liefert eine Antwort, die entweder als Quotient mit einem Rest oder als reine Dezimalzahl geschrieben werden kann.

Im Allgemeinen: A/B = q mit Rest r Zum Beispiel: 12/4 = 3 mit Rest 0, was in Dezimalform 3,0 geschrieben werden kann 13/4 = 3 mit Rest 1, was in Dezimalform 3,25 geschrieben werden kann 27/5 = 5 mit Rest 2, was in Dezimalform 5,4 geschrieben werden kann

5.1.2 Primzahlen

Eine Primzahl ist jede ganze Zahl, die durch keine andere ganze Zahl als 1 und sich selbst teilbar ist. Zum Beispiel:

20 ist keine Primzahl, weil sie durch 2, 4, 5 und 10 teilbar ist, was ganze Zahlen ergibt, z. B. 20 ÷ 4 = 5 - oder - 20 ÷ 10 = 2. 7 ist eine Primzahl, weil jede ganze Zahl, durch die man sie teilt, keine ganze Zahl ergibt, z. B. 7 ÷ 3 = 2,3333.

Einige Beispiele für Primzahlen sind 3, 5, 7, 11, 13, 97, 223, 997, 3413, 4421, 17837, 145601, 428567, 1171967, und noch viel größere Zahlen wie 2074722246773485207821695222107608587480996474721117292752992589912196684750549658310084416732550077 oder die Zwillingsprimzahlen 2.996.863.034.895 × 2^1.290.000 ± 1, die jeweils über 350.000 Stellen haben!

5.1.3 Modulare Arithmetik

Die modulare Arithmetik beschreibt Zahlen, die sich um eine bestimmte ganze Zahl herum bewegen. Ein intuitives Beispiel ist die 12-Stunden-Uhr. Wenn Sie 5 Stunden nach 23:00 Uhr aufbleiben, ist es nicht 16:00 Uhr! Stattdessen geht die Zeit um Mitternacht auf Null zurück (5 Stunden nach 23:00 Uhr ist also 4:00 Uhr am nächsten Tag).

Gegeben sind zwei beliebige positive Zahlen, A (der Dividend) und B (der Divisor),

A modulo B = der Rest r von A/B.

Im Zusammenhang mit Uhren könnte das Aufbleiben um 5 Stunden nach 23:00 Uhr wie folgt dargestellt werden:

(11:00 PM + 5 Stunden) mod 12 = ... = 16:00 mod 12 = 4:00 (AM)

5.1.4 Darstellung ganzer Zahlen

Ganzzahlen können in vielen verschiedenen Kodierungen dargestellt werden, von denen einige in der Informatik häufig anzutreffen sind.

Die meisten Menschen sind mit dem "Dezimalsystem" zur Basis 10 vertraut, das Zahlen mit 10 Zeichen darstellt: 0,1,2,3,4,5,6,7,8,9.

Die "Hex"-Kodierung fügt 6 zusätzliche Zeichen hinzu, so dass ein Satz zur Basis 16 entsteht: 0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f.

Die Ganzzahl 11719682 zur Basis 10 kann als B2D402 zur Basis 16 ausgedrückt werden. Beachten Sie, dass ein größerer Zeichensatz weniger Ziffern (kürzere Zeichenfolgen) erfordert, um die gleiche Zahl auszudrücken.

Computer "denken" in der Basis-2 und verwenden nur die Zeichen "0" und "1". Dies wird als binär bezeichnet und die Zahl 11719682 (Basis-10) würde als 10110010110101010000000010 dargestellt werden.

Monero druckt endgültige Adressen und Schlüssel in Base-58, was arabische Ziffern und den größten Teil des lateinischen Zeichensatzes (sowohl Groß- als auch Kleinbuchstaben) verwendet. Es ähnelt einem anderen Schema namens Base64, wurde jedoch modifiziert, um Zahlen und Buchstaben zu vermeiden, die beim Ausdruck zweideutig aussehen könnten. Monero verwendet dieses Format ausschließlich aus Gründen der Bequemlichkeit für menschliche Benutzer, die oft lange Adressen manuell lesen oder transkribieren müssen.

Das Basis-58-Alphabet lautet: 123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz

Anmerkung: Die Null (0) sowie die Buchstaben I (Großbuchstabe i), O (Großbuchstabe o) und l (Kleinbuchstabe L) sind in diesem Base58-Alphabet nicht enthalten, da sie nicht eindeutig voneinander unterscheidbar sind.

5.1.5 Elliptische Kurven
5.1.5.1 Allgemeine Einführung

Elliptische Kurven sind definiert als die Menge der 2-dimensionalen (x, y) Punkte, die eine Gleichung erfüllen:

y^2=x^3+ax+b.

Mit den festen Koeffizienten a = 2 und b = 3 lautet diese Gleichung zum Beispiel

y^2=x^3+2x+3,

die von vielen Punktpaaren erfüllt wird, wie z. B.:

x = 3 und y = 6 x = 3 und y = -6 x = -1 und y = 0.

5.1.5.2 Ed25519 Twisted Edwards

Monero verwendet eine bestimmte elliptische Kurve von Twisted Edwards für kryptografische Operationen, Ed25519, die das birationale Äquivalent der Montgomery-Kurve Curve25519 ist.

Die Ed25519-Kurve kann algebraisch ausgedrückt werden als

- x^2 + y² = 1 - (121665/121666) x² y².

Wenn man an unsere allgemeine Gleichung für elliptische Kurven zurückdenkt, ist diese Twisted-Edwards-Kurve ein Spezialfall mit den Parametern:

a = -1 und b = 121665/121666.

Kürzlich wurde klar, dass ein vom NIST unterstützter PRNG (Pseudo-Zufallszahlengenerator-Algorithmus) fehlerhaft ist und eine potenzielle Hintertür enthält. Da die NIST4-Standardalgorithmen in letzter Zeit Probleme aufwiesen, wurde die Twisted-Edwards-Kurve ausgewählt, um viele Bedenken der Kryptographiegemeinschaft auszuräumen.

Aus einem großeren Blickwickel betrachet, werden die vom NIST ausgewählten Kurven auch implizit von der NSA unterstützt. Diese Unterstützung wird von der Kryptographie- und Kryptowährungsgemeinschaft misstrauisch beäugt, da die NSA in der Vergangenheit ihre Autorität gegenüber dem NIST genutzt hat, um Algorithmen zu schwächen, die vom NIST vorgeschlagen wurden.

Die Twisted-Edwards-Kurve Ed25519 unterliegt keinen Patenten, und das Team, das dahinter steht, hat grundlegende kryptografische Algorithmen mit Blick auf Effizienz entwickelt und angepasst. Diese Kurve gilt derzeit als sicher.

5.1.5.3 Elliptische Operationen

Elliptische Kurvenpunktaddition und Skalarmultiplikation sind grundlegende Operationen für elliptische Kurvenkryptographieverfahren. Es ist hilfreich, ein grundlegendes Verständnis dieser Konzepte zu haben, bevor wir in die Mechanik von Moneros Berechnungen eintauchen.

Die Addition von Punkten auf elliptischen Kurven funktioniert anders als die typische Addition, die man in der Alltagsarithmetik findet. Um zwei Punkte auf einer elliptischen Kurve zu addieren, müssen Sie die Linie zwischen diesen beiden Punkten und dann den Punkt finden, an dem sich die Kurve mit dieser Linie schneidet. Dieser Punkt wird dann an der x-Achse gespiegelt, um den Endpunkt zu erhalten.

Bei der Addition eines Punktes zu sich selbst, der so genannten Punktverdopplung, muss man die Tangente an den Ausgangspunkt finden, um zu dem Punkt zu gelangen, an dem sich diese Tangente mit der Kurve schneidet. Dieser Punkt wird dann an der x-Achse gespiegelt, um den Endpunkt zu erhalten.

Bei der skalaren Multiplikation wird sowohl ein Punkt auf der Kurve als auch eine ganze Zahl verwendet. Um einen Punkt P mit einer ganzen Zahl S zu multiplizieren, wird der Punkt S-mal zu sich selbst addiert. Viele kryptografische Verfahren, wie die von Monero verwendeten, verwenden einen gemeinsamen Basispunkt auf der elliptischen Kurve als Generatorpunkt, um öffentliche Schlüssel aus privaten Schlüsseln zu erzeugen.

Wenn der Kurvengeneratorpunkt viele Male zu sich selbst addiert wird, kann der resultierende Punkt nicht verwendet werden, um festzustellen, wie oft der Vorgang stattgefunden hat. Dieses Problem wird oft als das Problem des diskreten Logarithmus der elliptischen Kurve bezeichnet. Diese Art der Skalarmultiplikation wird als Einwegfunktion betrachtet, da die Umkehrung der Operation so schwierig ist.

5.2 Grundlagen der Kryptographie

Monero ist die führende sichere und nicht zurückverfolgbare Kryptowährung dank seiner einzigartigen, auf den Schutz der Privatsphäre ausgerichteten kryptografischen Eigenschaften, die wir in diesem Kapitel genauer betrachten werden. Aufgrund der mathematischen Natur der Kryptographie ist dies eines der technischeren Kapitel des Buches. Komplexere Techniken bauen auf einfachen Prinzipien auf, die als kryptografische Stammfunktionen bekannt sind.

Eine kryptografische Stammfunktion ist ein Algorithmus, der als Baustein für kryptografische Protokolle dient. Monero verwendet eine Vielzahl von kryptographischen Stammfunktionen für verschiedene Zwecke, von denen wir einige in den Kapiteln 3 und 4 konzeptionell behandelt haben. Moneros absichtliche Ansätze zum Schutz der Privatsphäre und zum (ASIC-resistenten) "Proof-of-Work" erfordern anspruchsvollere kryptografische Werkzeuge als die, die von vielen anderen Kryptowährungen verwendet werden.

5.2.1 Symmetrische und asymmetrische Kryptographie

Für die Verschlüsselung von Daten können Algorithmen als symmetrisch oder asymmetrisch bezeichnet werden, je nachdem, welche Art von Schlüssel verwendet wird.

Bei der symmetrischen Verschlüsselung müssen die Teilnehmer ein Geheimnis teilen, z. B. verschlüsseln Sie eine Nachricht mit dem Kennwort "hunter2" und der Empfänger verwendet das Kennwort "hunter2", um sie zu entschlüsseln. Um auf diese Weise zu kommunizieren, müssen sich beide Parteien im Voraus auf das gemeinsame (symmetrische) Geheimnis einigen. Dieses praktische Problem schränkt den Nutzen der symmetrischen Verschlüsselung für viele Anwendungen ein.

Die asymmetrische Verschlüsselung ermöglicht es zwei Parteien, sicher miteinander zu kommunizieren, ohne ein bestimmtes Geheimnis zu teilen. Diese Art der Kryptografie ist in den Rahmen der Internetsicherheit, der End-to-End-Messenger und der Kryptowährungen eingebettet.

Bitcoin verwendet eine asymmetrische Verschlüsselung mit zwei Schlüsseln:

    privater Schlüssel - zum Signieren von Transaktionen und zum Entschlüsseln von Daten
    öffentlicher Schlüssel - für die Überprüfung der Unterschrift und die Verschlüsselung von Daten

Der komplexere kryptografische Rahmen von Monero erfordert vier Schlüssel:

    Public View Key - wird zur Überprüfung der Gültigkeit von Adressen verwendet
    privater Ansichtsschlüssel - zum Anzeigen von Daten wie Guthaben, Gebühren und Transaktionsbeträgen (der Ansichtsschlüssel kann keine Transaktionen erstellen       oder unterzeichnen)
    öffentlicher Ausgabenschlüssel - ein weiterer öffentlicher Schlüssel zur Überprüfung von Transaktionen
    privater Ausgabe-Schlüssel - wird zum Signieren von Transaktionen verwendet, d.h. zum Senden von Moneroj

Ihre öffentliche Monero-Adresse ist eine direkte Repräsentation des Paares öffentlicher Schlüssel, während Bitcoin (und Klone) einen Hash ihres einzelnen öffentlichen Schlüssels verwenden. EdDSA-Schlüssel (sowohl private als auch öffentliche) sind 256 Bit lang, oder 64 hexadezimale Zeichen. Nicht jede 256-Bit-Ganzzahl ist ein gültiger EdDSA-Skalar (privater Schlüssel); sie muss kleiner sein als die "Kurvenordnung", die mit der Gleichung im Abschnitt Ed25519-Funktion beschrieben wird.

5.2.2 Hashing

In Kapitel 4 wurde das Konzept des Hashings besprochen und wie es von der Bestätigung der Datentreue bis zur Verteilung von Belohnungen in "Proof-of-Work" verwendet wird. Beispiele für Hashes werden im Abschnitt über Kryptographie am Ende von Kapitel 4 gezeigt.

Die Auswahl eines guten Hash-Algorithmus ist entscheidend für die sichere Erzeugung von Adressen und Schlüsseln. Wenn zwei verschiedene Eingaben die gleiche Hash-Ausgabe erzeugen, wird dies als Kollision bezeichnet. Hashes werden in Blockchain-Systemen häufig als Bezeichner verwendet, da sie eindeutig sind. Außerdem würde eine Kollision bei der Seed-Generierung dazu führen, dass mehrere Personen dieselben Schlüssel und Adressen besitzen, was natürlich äußerst problematisch wäre!

Monero verwendet das CryptoNight PoW-System, das einen speziellen CryptoNote-Hash-Algorithmus verwendet, der auf dem Keccak-Hash-Algorithmus aufgebaut ist. Der Keccak-Algorithmus gewann einen NIST-Wettbewerb, um als SHA3 bezeichnet zu werden, und wurde von Nicht-NSA-Ingenieuren entwickelt. Monero verwendet die Keccak-256-Hash-Funktion mit 32-Byte-Ausgabe sowohl für das Transaktions- als auch für das Block-Hashing.

5.2.3 Monero Pseudozufallszahlengenerierung (PRNG)

Wenn Benutzer und Computer neue Schlüssel erzeugen, ist es wichtig, dass sie neue Schlüssel finden, die andere nicht erraten können. Dies ist eigentlich eine sehr schwierige Aufgabe, da sowohl Hardware als auch Software in der Regel so konzipiert sind, dass sie die Reproduzierbarkeit fördern. Wenn der Computer die Zufälligkeit auf vorhersehbare Weise erzeugt, kann die Ausgabe scheinbar zufällig sein, aber leichter zu erraten sein.

Nehmen wir zum Beispiel einen PRNG, der einfach die Ziffern der aktuellen Uhrzeit mischt, um einen vierstelligen Schlüssel zu erzeugen. Um "10:34" könnte er also "0413" oder "1403" oder "0134" ausgeben ... Wenn Sie den Ausgabeschlüssel geheim halten wollen, wäre dies aus mehreren Gründen eine schlechte Methode:

Ein Angreifer, der weiß, dass Sie Ihren Schlüssel erstellt haben, als Sie um 12:45 Uhr zur Arbeit kamen, würde wissen, dass die Ziffern "1" und "2" erscheinen, was die Auswahl auf deutlich weniger Optionen einschränkt.

Es gibt keine HH:MM-Tageszeiten mit drei "9 "s. Tatsächlich gibt es keine Zeiten mit drei beliebigen Ziffern aus {6,7,8,9}, da 17:89 Uhr, 18:78 Uhr usw. unmögliche Zeiten sind. Diese Regel eliminiert viele 4-stellige Pins, so dass der Angreifer aus einem viel kleineren Pool raten muss.

Der oben beschriebene uhrzeitbasierte Zufallszahlengenerator ist schrecklich, weil die Verwendung der Tageszeit als Anfangswert vorhersehbar ist. Der Anfangswert sollte für einen Angreifer viel schwieriger zu erraten sein. Gute Zufallszahlengeneratoren bringen eine Menge Entropie ein, um ihre Ergebnisse unvorhersehbar zu machen. Das einfache Mischen von 4 Ziffern führt nicht viel Entropie ein, was ein weiterer Grund dafür ist, dass unser obiger PRNG unsicher wäre.

Bei der Generierung von Wallets liefert das Betriebssystem des Benutzers den anfänglichen Seed / die Entropiequelle. Monero wendet dann wiederholt die Keccak-Hashing-Funktion an, um eine unvorhersehbare und nicht reproduzierbare Ausgabe zu erhalten. Jede Hash-Runde erzeugt eine Ausgabe, die als Eingabe für den nächsten Hash verwendet wird.

5.3 Generierung von Monero-Schlüsseln und -Adressen
5.3.1 Auswählen eines Seeds

In Kapitel 2 haben wir über das Herzstück Ihrer Wallet gesprochen: ihren Seed. Ihre Wallet generiert dieses Geheimnis, das verwendet wird, um alle Ihre Schlüssel abzuleiten und auf Ihr Geld zuzugreifen bzw. es auszugeben. In diesem Überblick haben wir lediglich die 25-Wort-Seed-Merkhilfe betrachtet.

Hinter den Kulissen ist ein Seed eine einzigartige 256-Bit-Ganzzahl, von der Schlüssel und Adressen abgeleitet werden, z. B:

112699108505435943726051051450940377552177626778909564691673845134467691053980 Diese werden oft als 64-stellige Basis-16-Zahl dargestellt, zum Beispiel:

f9296f587419f1cdede67de160fca14d1069ecaa4c52f012af031eeA09ee039c

(Bei mnemotechnischen Schlüsseln ist diese Darstellung des Seed eigentlich nur der private Spend Key selbst).

Es wäre also ziemlich schwierig, einen der beiden oben genannten Schlüsselarten aufzuschreiben, und die meisten Leute würden mindestens einen Fehler machen. Die Umwandlung in eine mnemonische Phrase für den Seed ist ein weiterer Schritt, der nur aus Gründen der menschlichen Interpretierbarkeit und Benutzerfreundlichkeit erfolgt. Die mnemonische Phrase wandelt die oben genannte 256-Bit-Zahl im Wesentlichen in eine 24-stellige (24 Wörter) Basis-1626-"Zahl" um (da es 1626 Wörter im Seed-Wörterbuch gibt). Diese Darstellung der langen Seed-Strings ist viel einfacher zu lesen:

Lamm Sechseck Asse erwerben Twang stumpf argumentieren, wenn unerschrocken Markise Akademie Nagel bedrohen Seemann Palast selbstsüchtig Kadetten klicken Krankheit jongliert Grenze Daumen Abhilfe Grate Grenze

Wenn Ihre Brieftasche den 24-Wort-Seed präsentiert, fügt sie ein 25. Wort hinzu, das als Prüfsumme fungiert und die spätere Erkennung von Tippfehlern oder Fehlern ermöglicht. Die mnemonische Methode von Monero kodiert mit einem Mindestverhältnis von 4:3. Mit anderen Worten: Vier Bytes ergeben drei Wörter plus ein Prüfsummenwort; acht Bytes ergeben sechs Wörter plus ein Prüfsummenwort und so weiter.

Der private View-Schlüssel wird abgeleitet, indem der Seed mit Keccak-256 gehasht wird, wodurch eine zweite 256-Bit-Ganzzahl erzeugt wird, die dann an die Funktion sc_reduce32 gesendet wird, um sicherzustellen, dass sie mit der elliptischen Kurve kompatibel ist. Die mit dieser Methode erzeugten Seeds sind immer gültige Skalare, da sie zuerst an sc_reduce32 gesendet werden.

5.3.2 Schlüsselableitung
5.3.2.1 Alle Schlüssel

Der oben beschriebene Monero-Seed ist eigentlich Ihr geheimer Ausgabenschlüssel, von dem alle anderen Schlüssel abgeleitet werden. Der geheime View-Schlüssel ist der reduzierte Hash Ihres geheimen Spend-Schlüssels, umgewandelt in einen gültigen Skalar für die ed25519-Kurve.

Diese beiden privaten Schlüssel werden mit dem Generatorpunkt multipliziert, um die beiden öffentlichen Schlüssel für Ihre Brieftasche (public spend und public view) zu erhalten. Diese Methode zur Ableitung der Schlüssel wird als deterministische Methode bezeichnet.

5.3.2.2 Only-View-Wallets

Sie können einen "Nur-Ansicht-Zugang" zu einem Monero-Konto gewähren, indem Sie eine Wallet mit Ihrem geheimen Ansichtsschlüssel, aber NICHT mit dem geheimen Ausgabenschlüssel einrichten. Diese "View-only"-Wallets können alle eingehenden Transaktionen sehen, aber keine Moneroj ausgeben oder ausgehende Transaktionen sehen.

Es gibt mehrere Situationen, in denen es nützlich ist, eingehende Transaktionen ohne Sendezugriff zu überprüfen. Zum Beispiel können Personen mit Cold Wallets den View Key verwenden, um zu überprüfen, ob Gelder angekommen sind, während ihr geheimer Spend Key sicher verwahrt wird. Ebenso können Entwickler Systeme entwickeln, die eingehende Zahlungen erkennen und darauf reagieren können, ohne dass sie die Möglichkeit haben müssen, diese Gelder zu bewegen.

Diese Funktion ist besonders wertvoll für Wohltätigkeitsorganisationen, die ihren View Key weitergeben können, um Transparenz und Verantwortlichkeit im Zusammenhang mit Spenden zu gewährleisten. Wenn Sie eine Spende an eine öffentliche Adresse tätigen, können Sie den View Key verwenden, um zu überprüfen, ob die Wohltätigkeitsorganisation Ihre Gelder erhalten hat.

Ein Beispiel dafür ist die Spendenadresse des Monero General Fund: 44AFFq5kSiGBoZ4NMDwYtN18obc8AemS33DBLWs3H7otXft3XjrpDtQGv7SqSsaBYBb98uNbr2VBBEt7f2wfn3RVGQBEP3A.

Da Stealth-Adressen verhindern, dass die öffentliche Adresse in der Blockchain aufgezeichnet oder auffindbar ist, veröffentlicht die Community auch den View Key (f359631075708155cc3d92a32b75a7d02a5dcf27756707b47a2b31b21c389501), damit die Öffentlichkeit die Spendenaktivitäten überprüfen kann.

Da jeder mit dem View Key den Gesamtbetrag sehen kann, den eine Wallet erhalten hat, kann eine transparente Wohltätigkeitsorganisation, die 100 XMR geschenkt bekommen hat, nicht 90 XMR abzweigen und behaupten, sie hätte nur 10 XMR erhalten. Diese Funktion ist besonders wertvoll für Crowdfunding-Situationen, bei denen eine bestimmte Spendenschwelle erreicht werden muss.

Die Unmöglichkeit, ausgehende Transaktionen von einer Wallet, die nur angezeigt wird, zu sehen, ist eine Funktion, kein Fehler! Wenn die ausgehenden Transaktionen öffentlich gemacht würden, könnte man sehen, wann eine Ausgabe getätigt wurde. Dies wäre sehr problematisch, da Ring-Signaturen auf der Mehrdeutigkeit des Ausgabestatus beruhen. Angenommen, eine Wohltätigkeitsorganisation enthüllt, wann eine Ausgabe ausgegeben wurde; alle Erscheinungen in zukünftigen (und früheren) Ringsignaturen können als Köder identifiziert werden. Die Nichtoffenlegung ausgehender Transaktionen ist daher notwendig, um die Integrität des gesamten Netzwerks zu wahren.

Die "View-Only"-Wallet-Funktion von Monero könnte sich auch als Moneros Schutz gegen Regulierungen erweisen, die Monero in bestimmten Ländern verbieten wollen. Da einzelne Monero-Benutzer ihren privaten View-Key freigeben können, könnten sie ihn Prüfern zur Verfügung stellen, um ihr Geld zu verifizieren. Dies wäre ein vernünftiger Ansatz, um Wirtschaftsprüfer zu besänftigen und somit die Befürchtung zu zerstreuen, dass Monero nicht innerhalb der Paradigmen der bestehenden Finanzstrukturen funktionieren könnte.

5.3.3 Adressgenerierung

Die Standardadresse einer Monero-Wallet besteht aus den beiden öffentlichen Schlüsseln (dem öffentlichen Ausgabenschlüssel und dem öffentlichen Ansichtsschlüssel), die im letzten Abschnitt abgeleitet wurden. Sie enthält außerdem eine Prüfsumme und ein Netzwerkbyte, das sowohl das Netzwerk als auch den Adresstyp identifiziert.  

5.3.3.1 Netzwerk-Byte

Das Netzwerk-Byte wird zur Unterscheidung zwischen verschiedenen Kryptowährungen und Netzwerken verwendet. CryptoNote-Münzen geben die entsprechenden Werte in der Datei src/CryptoNote_config.h an, zum Beispiel

uint64_t const CRYPTONOTE_PUBLIC_ADDRESS_BASE58_PREFIX = 18;

Moneros Hauptnetzwerk verwendet '18', um eine primäre Adresse anzugeben (deshalb beginnen Moneros primäre Adressen mit einer '4', was die ASCII-Darstellung ist). Monero-Entwickler verwenden das Testnet und das Stagenet, die ihre eigenen einzigartigen Netzwerk-Bytes haben:
Name                                Code Wert    ASCII-Wert
Primäre Adresse des Hauptnetzes     18           4
Subadresse des Hauptnetzes          42           8
Primäre Adresse des Testnetzes      53           9
Testnetz-Subadresse                 63           B
Stufennetz-Primäradresse            26           5        
Stufennetz-Unteradresse             36           7

5.3.3.2 Verkettete öffentliche Schlüssel

Der öffentliche Spend-Schlüssel und der öffentliche View-Schlüssel werden verkettet und an das Netzwerkbyte angehängt, um die Rohadresse (alles außer der Prüfsumme) zu erzeugen. Diese Adresse ist zwar immer noch in einem Rohformat, enthält aber alle Schlüsselinformationen: Schlüssel für die Erstellung von Transaktionen und Netzwerk-Metadaten, um sicherzustellen, dass die Transaktionen dem richtigen Netzwerk gemeldet werden.

5.3.3.3 Prüfsumme

Da Monero-Transaktionen nicht rückgängig gemacht werden können, ist es wichtig, Zahlungen an die richtige Adresse zu senden! Um Tippfehler und kleinere Fehler zu vermeiden, enthält die Adresse eine Prüfsumme. Wenn der Absender einen Tippfehler macht oder nicht die ganze Adresse erfasst, stimmt die Prüfsumme nicht überein, was bedeutet, dass die eingegebene Zeichenfolge keine gültige Adresse ist.

Diese Prüfsumme wird durch Keccak-Hashing der im vorherigen Abschnitt gesammelten Adressinformationen erzeugt. Der Hashwert wird auf die ersten 4 Bytes gekürzt und als Prüfsumme verwendet.

5.3.3.4 Alles zusammenführen: Adressfinalisierung

Zum Schluss werden das Netzwerkbyte, die Schlüssel und die Prüfsumme gemäß der Monero-Spezifikation zusammengefügt:
Index   Größen in Bytes     Beschreibung
0       1                   identifiziert das Netzwerk und den Adresstyp - "18" für das Hauptnetz und "53" für das Testnetz (in Basis-58, "4" bzw. "9")
1       32                  Schlüssel für öffentliche Ausgaben
33      32                  öffentlicher Schlüssel zur Ansicht
64      4                   Prüfsumme (mit der Keccak-Funktion aus den vorherigen 65 Bytes erstellter Hash, auf die ersten 4 Bytes gekürzt)

Abschließend wird diese 69-Byte-Ausgabezeichenfolge in das Monero-Base-58-Format kodiert. Durch diese Konvertierung erhöht sich die Länge auf eine 95-Zeichen-Zeichenfolge, die leicht zu lesen und zu schreiben ist. Das ist alles, was es zu tun gibt! Monero-Primäradressen bestehen einfach aus:

[Netzwerkbyte + Public Spend Key + Public View Key + Prüfsumme] Beispiel für eine Standardadresse: 4BKjy1uVRTPiz4pHyaXXawb82XpzLiowSDd8rEQJGqvN6AD6kWos LQ6VJXW9sghopxXgQSh1RTd54JdvvCRsXiF41xvfeW5

Der nachstehende Pseudocode beschreibt den Prozess der Generierung einer öffentlichen Adresse, wobei Hs() für Keccak-Hashing und "||" für die Verkettung von Zeichenketten verwendet wird.

Prüfsumme = Hs(Varint(Präfix) || Schlüssel für öffentliche Ausgaben || Schlüssel für öffentliche Ansichten) SerializedString = Base58(Präfix || Schlüssel für öffentliche Ausgaben || Schlüssel für öffentliche Ansichten || Prüfsumme)

Kapitel 7 enthält aktuellen Python-Code, um selbst Schlüssel und Adressen zu erzeugen!

5.3.4 Unteradressen

Der Datenschutz für Monero-Transaktionen wird durch drei primäre Konstruktionen erreicht: Ring-Signaturen, Stealth-(Einmal-)Adressen und RingCT. Diese vermindern das Risiko, dass Transaktionen durch die Analyse von Blockchain-Daten verknüpft werden. Man muss jedoch auch die Risiken der "Off-Chain"-Verknüpfbarkeit berücksichtigen (mit anderen Worten, Informationen, die aus anderen Quellen als den Blockchain-Daten selbst gesammelt wurden).

Nehmen wir zum Beispiel an, Ihre primäre Adresse hat Zahlungen von mehreren verschiedenen Personen erhalten. Dank der Stealth-Adressentechnologie von Monero wird Ihre öffentliche Adresse niemals explizit in Transaktionen aufgezeichnet, so dass niemand durch die Analyse der Blockchain (einschließlich der Geldgeber) eine Verbindung zu diesen Transaktionen herstellen kann. Diese kryptografische Privatsphäre wird jedoch vollständig umgangen, wenn zwei Ihrer Absender miteinander kommunizieren und feststellen, dass sie beide Moneroj an dieselbe Adresse gesendet haben!

Sie können dieses Risiko vermeiden, indem Sie mehrere Subadressen generieren und jedem Absender eine eindeutige Adresse zuweisen. Die Subadressen werden von denselben Schlüsseln wie Ihre Hauptadresse abgeleitet, so dass Gelder, die an eine beliebige Subadresse gesendet werden, zum selben Gesamtguthaben der Wallet geleitet werden. Die verschiedenen Subadressen sind jedoch kryptographisch nicht verknüpfbar, so dass mehrere Personen, die Moneroj an dieselbe Wallet senden, dies nicht durch einen Vergleich ihrer Adresslisten erkennen können.

5.3.4.1 Erstellen einer Unteradresse

Jede Brieftasche hat zwei Schlüsselpaare. Der private Ansichtsschlüssel (pV0) und der private Ausgabeschlüssel (pS0) werden geheim gehalten, während der öffentliche Ansichtsschlüssel (PV0) und der öffentliche Ausgabeschlüssel (PS0) in jeder Adresse verschlüsselt sind. Wie bereits erwähnt, werden die öffentlichen Schlüssel durch Multiplikation der privaten Schlüssel mit dem Generatorpunkt (G) auf der elliptischen Kurve erzeugt, d. h. (PV0, PS0) = (pV0, pS0)G.

Ihre Brieftasche kann eine große Anzahl von Unteradressen erstellen, jede mit einem anderen Index "i" (normalerweise beginnend bei i=1). Jede Unteradresse hat ihre eigenen Schlüsselsätze für jeden Index, mit eindeutigen privaten (pVi, pSi) und öffentlichen (PVi, PSi) Schlüsseln.

Die Formel zur Erstellung eines öffentlichen Schlüssels für die i-te Subadresse lautet:

PSi = Hs(pV0||i)G+PS0

Dieser Prozess beginnt mit der Verkettung des Index "i" mit dem privaten Schlüssel der Primäradresse (pV0) und der Übergabe des Ergebnisses an die Funktion hash_to_scalar (Hinweis: In der Praxis verkettet die Referenz-Client-Wallet auch die Zeichenkette SubAddr mit den Daten, die als Bindeglied für das Hashing dient). Der resultierende Skalar wird mit dem Kurvengeneratorpunkt multipliziert und durch elliptische Kurvenpunktaddition zum primären Public Spend Key hinzugefügt.

Dieser öffentliche Schlüssel für die Unteradresse wird mit dem primären Schlüssel für die private Ansicht multipliziert, um den öffentlichen Schlüssel für die Unteradresse zu erhalten:

PVi = pV0*PSi

Die öffentlichen Schlüssel der Subadresse werden in der öffentlichen Adresse nach der gleichen Konvention wie die primären Adressen kodiert:

Subadresse_i = base58(Netzbyte || PSi || PVi || Prüfsumme)

Das Hauptnetzbyte für Subadressen ist jedoch 0x42, weshalb sie alle mit der Ziffer "8" beginnen.

5.3.4.2 Senden an eine Subadresse

Dieses unterschiedliche erste Netzwerk-Bit ist von entscheidender Bedeutung, da Transaktionen an Subadressen etwas anders aufgebaut sein müssen als normal.

Beim Aufbau einer Transaktion generieren Wallets normalerweise 32 Zufallsbytes, die als privater Schlüssel dienen. Beim Senden an eine Primäradresse wird dieser Zufallsschlüssel mit dem Generatorpunkt der elliptischen Kurve durch skalare Multiplikation der elliptischen Kurve multipliziert, um den öffentlichen Schlüssel der Transaktion zu erhalten. Beim Senden an eine Unteradresse wird der private Transaktionsschlüssel stattdessen mit dem öffentlichen Ausgabenschlüssel der empfangenden Unteradresse multipliziert.

5.3.4.3 Empfangen an eine Subadresse

Aufgrund der verschleierten Natur der Monero-Blockchain muss eine Wallet jede Transaktion überprüfen, um festzustellen, ob sie dem Besitzer gehört. Um festzustellen, ob eine gegebene Ausgabe X (mit öffentlichem Transaktionsschlüssel R) an die Hauptadresse gesendet wurde, überprüft die Wallet Berechnungen auf der Grundlage ihres öffentlichen Ansichtsschlüssels und öffentlichen Ausgabenschlüssels. Wenn die Gleichheit X==Hs(pV0* R)G+PSi wahr ist, dann kann diese Ausgabe freigeschaltet und ausgegeben werden!

Das Verfahren zur Überprüfung, welche Ausgaben zu Unteradressen gehören, ist jedoch etwas anders. Die Berechnung ist größtenteils die gleiche, außer dass der Term hash_to_scalar von der Ausgabe abgezogen und mit den öffentlichen Ausgabenschlüsseln der Subadressen verglichen wird. Die Wallet weiß, dass sie eine Ausgabe gefunden hat, die ihr gehört, wenn die Gleichheit PSi == X - Hs(pV0 * R)G wahr ist.

5.3.5 Andere Methoden zur Schlüsselableitung

Um die Verwirrung noch zu vergrößern, gibt es derzeit mindestens 3 verschiedene Methoden zur Ableitung privater Schlüssel, die in Monero verwendet werden (dies ist auch bei Bitcoin der Fall). Diese Methoden unterscheiden sich in einigen "wichtigen" Aspekten:

    Original (nicht-deterministischer Stil): Der private Ausgabeschlüssel und der private Ansichtsschlüssel werden beide unabhängig und zufällig ausgewählt, um       ein Konto zu bilden. Es gibt keine gute Möglichkeit, ein nicht-deterministisches Konto zu sichern, abgesehen von der Aufbewahrung von Kopien der einzelnen         Dateien. Aufgrund besserer Alternativen wird diese schwerfällige Methode nicht mehr empfohlen.

    Mnemonischer (deterministischer oder "Electrum"-) Stil: Bei dieser Methode werden alle Schlüssel von einem einzigen privaten Schlüssel abgeleitet, der als         Seed bezeichnet wird. Der private View-Schlüssel wird durch Hashing des privaten Spend-Schlüssels mit Keccack-256 abgeleitet, um einen gültigen EdDSA-Skalar       zu erzeugen. Diese Konten sind leicht zu sichern, da Sie nur den Seed aufschreiben müssen (der normalerweise als Basis-1626-Mnemonik ausgedrückt wird).

    MyMonero-Stil: Die MyMonero-Wallet-Familie verwendet eine Methode, die der Electrum-Konvention ähnelt, allerdings besteht die Seed-Phrase aus 13 Wörtern           anstelle der üblichen 25 Wörter. Die 13 Wörter werden in eine 128-Bit-Ganzzahl umgewandelt, die sowohl für die Ableitung des Spend- als auch des View-             Schlüssels verwendet wird. Die Seed-Ganzzahl wird mit Keccak-256 gehasht und in den privaten Spend-Schlüssel umgewandelt. Dieser private Spend-Schlüssel wird     wiederum mit Keccak-256 gehasht und in den privaten View-Schlüssel umgewandelt.

Sie haben vielleicht einen entscheidenden Unterschied zwischen den Seed-Styles von MyMonero und Electrum bemerkt. MyMonero erstellt den Private View Key durch Hashing einer zufälligen Ganzzahl, während Electrum den Private Spend Key hasht. Das bedeutet, dass die 13- und 25-Wort-Seeds nicht kompatibel sind - es ist nicht möglich, ein Electrum-Konto zu erstellen, das mit einem MyMonero-Konto übereinstimmt (oder umgekehrt), da das Schlüsselpaar der Ansicht immer unterschiedlich sein wird.

5.4 Die Datenschutztechnologien
5.4.1 Tarnadresse

In Kapitel 3 wurde konzeptionell beschrieben, wie Einmaladressen, auch Stealth-Adressen genannt, es ermöglichen, Transaktionen ins Netz zu stellen, ohne die wahre Adresse des Empfängers preiszugeben. In diesem Abschnitt wird die Kryptographie hinter dem einmaligen öffentlichen Schlüssel näher erläutert.
5.4.1.1 Versenden

Das CryptoNote-Protokoll berechnet die einmalige Empfangsadresse nach der Formel X = Hs(r* PV|i)G + PS. Gehen wir die Bedeutung dieser Symbole durch und erklären wir, wie Maria eine Einmaladresse generiert, wenn sie Geld an Georg sendet.

Die Variable r ist der private Transaktionsschlüssel, ein pseudozufälliger Skalar mit 256 Bit. Maria (die Absenderin) ist die einzige Person, die diesen Schlüssel jemals kennen wird; selbst George (der Empfänger) erfährt nie die Zufallszahl, die Marias Brieftasche für r gewählt hat.

Maria multipliziert dann Georges Public-View-Schlüssel PV mit r und fügt den Ausgabeindex i an. Diese Menge (r* PV|i) wird dann durch die Hash_to_scalar-Funktion Hs() geleitet. Diese Funktion hasht ihre Eingaben mit dem Keccak-256-Algorithmus und multipliziert den resultierenden Hash mit der Primzahl 2^255 + 27742317777372353535851937790883648493.

Der im obigen Absatz berechnete Term Hs(r* PV|i) wird mit dem Basiswert ed25519, G, multipliziert. Schließlich addiert Maria diese Menge zu Georges öffentlichem Schlüssel PS, um die endgültige Ausgabe X zu erhalten, die die Tarnadresse ist.

Mit diesem komplizierten Verfahren kann Maria die Transaktion für George auf der Blockchain verbergen, indem sie eine zufällig erzeugte Einmaladresse verwendet, die niemand mit ihm in Verbindung bringen kann.
5.4.1.2 Empfangen

Wenn man bedenkt, wie gut Maria die Moneroj, die sie an George sendet, versteckt hat (durch einen privaten Transaktionsschlüssel, den selbst George nicht kennt), kann man sich fragen, wie er sie in der Blockchain finden kann!

Wie in Kapitel 3 beschrieben, muss George die Blockchain nach Ausgaben durchsuchen, die ihm gehören. Der Prozess ist der Methode sehr ähnlich, die Maria zur Generierung der Adresse verwendet hat.

George nimmt den öffentlichen Transaktionsschlüssel R aus der Blockchain und multipliziert ihn mit seinem privaten View Key, pV. Nach ähnlichen Schritten wie Maria fügt George den Ausgabeindex i an und wendet dann die Funktion hash_to_scalar auf (pV*R|i) an. Anschließend multipliziert er das Ergebnis mit G und fügt seinen eigenen öffentlichen Ausgabenschlüssel PS hinzu. Wenn dieser Wert mit der Ausgabe übereinstimmt, dann gehört sie ihm.

Mit anderen Worten: Georges Wallet durchsucht jede Transaktion in der Blockchain, um Ausgaben zu identifizieren, bei denen X = Hs(pV* R|i)G + PS ist.
5.4.2 Ringvertrauliche Transaktionen

Ring Confidential Transactions (RingCT) verschleiert die Menge an Moneroj, die in einer Transaktion gesendet wird. RingCT wurde im Januar 2017 eingeführt und ist seit September 2017 für alle Transaktionen verpflichtend.

Nur Transaktionen, die neue Moneroj als Coinbase-Belohnungen prägen, haben sichtbare Beträge, die nicht durch RingCT maskiert werden. Dies ist eine Prüfungsfunktion, die es jedem Netzwerkteilnehmer ermöglicht, genau zu zählen und zu überprüfen, wie viele Moneroj generiert wurden. Nach dieser öffentlichen Münzausgabe werden diese Transaktionen vor der weiteren Verwendung in RingCT-Ausgaben umgewandelt.

Alle Nicht-Coinbase-Transaktionen verwenden RingCT, um den Transaktionsbetrag zu verschlüsseln. Der Betrag für jede Transaktion wird auf zwei verschiedene Arten verschlüsselt, die beide in der Nachricht enthalten sind.

Zunächst wird der Betrag mit einem Schlüssel verschlüsselt, der aus den öffentlichen Informationen der Adresse des Empfängers abgeleitet wird. Diese Version wird im Feld ecdhInfo gespeichert und kann nur vom Empfänger unter Verwendung des gemeinsamen Transaktionsgeheimnisses entschlüsselt und gelesen werden.

Zweitens wird der Betrag in eine Pedersen-Verpflichtung integriert, die es anderen Monero-Nutzern ermöglicht, die Gültigkeit der Transaktion selbst zu überprüfen. Niemand kann den Transaktionsbetrag aus der Pedersen-Zusage abrufen, aber jeder kann das Ergebnis einsehen, um mathematisch zu überprüfen, dass die Ausgaben die Eingaben ausgleichen. Dies verhindert Transaktionen, die versuchen, Moneroj zu fälschen.

Es gibt zwei Schlüsselaspekte bei der RingCT-Verifizierung:

    Der Sender beweist nachweislich, dass alle Ausgaben einen positiven Betrag enthalten, indem er einen Bereichsbeweis verwendet. Der Bereichsbeweis zeigt, dass die maskierte Zahl als Summe positiver Potenzen von 2 generiert werden kann, ohne diese Potenzen zu verraten. Ohne Bereichsbeweise könnte ein hinterhältiger Benutzer mit 5 XMR eine Transaktion mit einem Paar von Ausgaben erstellen, die +13 XMR und -8 XMR enthalten.

    Der Absender weist auch nach, dass die Eingänge die Ausgänge ausgleichen, was nicht trivial ist, wenn man bedenkt, dass Ringsignaturen Köder enthalten, um zu verhindern, dass die überprüfende Partei die wahre Quelle der Eingangsmittel kennt! Homomorphe Pederson-Verpflichtungen ermöglichen es dem Absender zu beweisen, dass eine der potenziellen Eingaben eine Null-Differenz zu den Ausgaben hat, ohne dabei den Betrag preiszugeben.

Als einfache Analogie können Sie sich die folgenden Beispielgleichungen vorstellen. Wie bei maskierten Transaktionsbeträgen können Sie überprüfen, ob jede Gleichung gültig ist, ohne den Wert von A zu kennen.

A = unsere Ausgabe, niemand weiß, dass

5A + 1A + 4A = 10A WAHR! Geprüft, ohne A zu kennen

6A + 4A + 2A = 14A FALSCH! Nicht verifiziert, abgelehnt!

5.4.3 Ring-Signaturen

Monero nutzt die Ringsignatur-Technologie, um die Privatsphäre des Absenders jeder Transaktion zu schützen. Eine Ringsignatur ist eine Art von kryptographischer Signatur, die es einem aktiven Teilnehmer ermöglicht, eine Nachricht im Namen einer Gruppe zu signieren. Der private Schlüssel des aktiven Unterzeichners wird mit den öffentlichen Schlüsseln der anderen Mitglieder gemischt, um eine einzige Signatur zu erstellen. Jeder kann die signierte Nachricht mit den öffentlichen Schlüsseln abgleichen, um zu überprüfen, ob eines der Ringmitglieder die Signatur veranlasst hat; es ist jedoch unmöglich festzustellen, welches Mitglied den privaten Schlüssel beigesteuert hat.

Im Kontext von Monero ist die Nachricht eine Transaktion, die durch die Ringsignatur autorisiert wird. Die Ausgabe, die tatsächlich ausgegeben wird, ist der wahre Unterzeichner, und die öffentlichen Schlüssel von anderen Ausgaben (aus vergangenen Transaktionen) werden als Scheinunterzeichner beigemischt. Der tatsächliche Unterzeichner und die Scheinunterzeichner sind mathematisch gleichwertig; die resultierende Ringsignatur kann nicht kryptografisch untersucht werden, um festzustellen, welches Mitglied die Signatur aktiv initiiert hat. Folglich kann keine außenstehende Partei (einschließlich des Empfängers) feststellen, welche der in einer Transaktion referenzierten Ausgaben tatsächlich ausgegeben wurde.

Jede Ringsignatur erzeugt ein einziges Schlüsselbild, das von der tatsächlich ausgegebenen Ausgabe abgeleitet ist. Dies ist ein kryptographisch sicheres Verfahren: Jede Ausgabe entspricht einem einzigen Schlüsselbild, und die Erstellung des Schlüsselbildes verrät nicht den wahren Unterzeichner im Ring.

Wenn der Besitzer einer Ausgabe diese in einer neuen Transaktion ausgibt, speichert das Netz das durch die Ringsignatur erzeugte Schlüsselbild. Da das Netz nicht erkennen kann, welche Ausgaben getätigt wurden, verfolgt es stattdessen, welche Schlüsselbilder ausgegeben wurden! Würde der Besitzer versuchen, die Ausgabe erneut in betrügerischer Absicht auszugeben, würde dasselbe Schlüsselbild erzeugt werden, so dass das Netzwerk weiß, dass es die Transaktion ablehnen muss.

Sehen wir uns nun die eigentliche Mathematik der Erzeugung einer Ringsignatur an. In diesem Beispiel soll HS eine Hash-Funktion sein, die Skalare (im entsprechenden Feld) zurückgibt, und HP eine Hash-Funktion, die Punkte (in der entsprechenden Kurvengruppe) zurückgibt. Um Komplikationen zu vermeiden, verzichten wir bewusst auf eine formale Definition dieser Domänen und Codomänen. G sei ein fester Punkt, der allen Parteien bekannt ist.

Sie werden die Transaktionsnachricht M mit einer Ringsignatur signieren. Monero benötigt derzeit elf Ringmitglieder für jede Signatur, aber lassen Sie uns ein vereinfachtes Beispiel mit drei Ringmitgliedern betrachten. Sie haben das Schlüsselpaar (öffentlich und privat) für den Ausgang, den Sie ausgeben, und wählen zwei andere Ausgänge (und deren öffentliche Schlüssel), die als Lockvogel dienen. Natürlich sollte die Indizierung der Ringmitglieder zufällig sein, da die kryptografische Anonymität umgangen würde, wenn der wahre Unterzeichner immer in Slot 1 wäre. Nehmen wir für das vereinfachte Beispiel mit drei Ringmitgliedern an, dass Ihre Brieftasche den wahren Geldgeber nach dem Zufallsprinzip in Slot 2 platziert hat.

Sie rufen die öffentlichen Ausgabeschlüssel für die Lockvögel (P1 und P3) aus der Blockchain ab und verfügen sowohl über den privaten Schlüssel (p2) als auch den öffentlichen Schlüssel (P2 = p2G) für die Ausgabe, die Sie tätigen wollen. Zu Beginn wählen Sie eine Zufallszahl u, die Sie später verwerfen werden. Zunächst bilden Sie die folgende Verpflichtung, beginnend mit dem Index nach demjenigen, den Sie für Ihren Schlüssel gewählt haben:

c3 = Hs(M,uG,uHp(P2))

Um die restlichen Verpflichtungen zu bilden, wählst du auch die Zufallszahlen s3 und s1, die du später brauchen wirst:

c1 = Hs(M,s3G + c3P3 , s3Hp(P3) + c3p2Hp(p2))

Beachten Sie, dass Sie hier mehrere Informationen einbeziehen: den öffentlichen Schlüssel P3, den Sie aus der Blockchain entnommen haben, die Zufallszahl s3, die Sie sich ausgedacht haben, die vorherige Verpflichtung c3 und einen Wert p2 Hp (P2), der aus Ihrem eigenen Schlüssel gebildet wurde. Sie machen weiter:

c2 = Hs(M, s1G + c1P1, s1Hp(P1) + c1p2Hp(P2))

Aber Sie sind noch nicht ganz fertig! Um zu verbergen, wo sich Ihr tatsächlicher Schlüssel befindet, definieren Sie clevererweise s2 = u - c2 p2. Die Signatur, die Sie an die Blockchain und die Welt senden, enthält mehrere Größen: (c1 , s1 , s2 , s2 , J), wobei J = p2Hp(P2) das in jeder Verpflichtung verwendete Schlüsselbild ist. Wir benennen es hier um, um zu verdeutlichen, dass die Öffentlichkeit nicht weiß, aus welchen Teilen es gebildet wurde.

Der Clou: Wenn Sie s2 = u - c2 p2 setzen, können Sie umrechnen und sehen, dass u = s2 + c2p2 ist. Dies bedeutet, dass die Öffentlichkeit die erste Verpflichtung c3, die Sie eingegangen sind, wie folgt sieht:

c3 = Hs(M, s2G + c2P2, s2Hp(P2) + c2p2Hp(P2))

Das sieht genauso aus wie die anderen Verpflichtungen! Obwohl Sie u nie ausstrahlen, nutzen Sie es geschickt, um jede Verpflichtung in den Augen der Beobachter identisch aussehen zu lassen. Das ist die Macht der Ringsignatur. Niemand kann feststellen, welche Verpflichtung Ihren wahren Schlüssel verbirgt, aber jeder kann für sich selbst mathematisch nachprüfen, dass:

    der Absender einen der privaten Schlüssel kannte, die durch die öffentlichen Schlüssel repräsentiert werden
    das Schlüsselbild korrekt berechnet wurde

Beachten Sie, dass das Schlüssel-Image J = p2Hp(P2) eindeutig aus dem Schlüsselpaar der echten Ausgabe berechnet wurde, ohne Zufallszahlen oder öffentliche Schlüssel von Lockvögeln. Daher wird jeder betrügerische Versuch, die Ausgabe ein zweites Mal auszugeben, ein identisches Schlüsselbild erzeugen. Da das Netz verfolgt, welche Schlüsselbilder verwendet wurden, werden Versuche, die Ausgaben erneut zu verwenden, leicht erkannt und zurückgewiesen.

Bitte beachten Sie, dass das obige Beispiel einer LSAG-Ringsignatur im Back-Style nur zu Lehrzwecken dient und nicht als Referenzdokument für Produktionsimplementierungen verwendet werden sollte.

5.4.4 Weitere Ressourcen

Wenn Sie noch tiefer in die Berechnungen hinter diesen Technologien einsteigen möchten, lesen Sie "Zero to Monero" von Alonso, K.M. & Koe. Dieses Buch ist ein hochtechnischer mathematischer Rundgang, der auch als kostenloses, von der Community finanziertes PDF verfügbar ist.
5.5 Die Monero-Blockchain

Inzwischen sind Sie mit der Bedeutung und dem Nutzen von Blockchains als verteilten öffentlichen Ledgern vertraut. Diese Blöcke werden in einer unveränderlichen, nur anhängenden Datenbank strukturiert und geordnet, die durch kryptografische Werkzeuge gesichert ist, die jegliche Manipulation oder Betrug verhindern. Die Blockchain von Monero ist einzigartig und wir werden ihre Technologie und Spezifikationen in diesem Abschnitt diskutieren.
5.5.1 Lightning Memory Mapped Datenbank

Monero verwendet das Lightning Memory Mapped Database (LMDB) System, um seine Blockchain zu speichern. LMDB ist eine Softwarebibliothek, die eine leistungsstarke eingebettete Transaktionsdatenbank in Form eines Key-Value-Speichers bereitstellt. Dies bedeutet, dass sie hocheffektiv und leicht zu durchsuchen ist.

LMDB ist in C++ geschrieben, verfügt über API-Anbindungen an verschiedene Programmiersprachen und wird von der Symas Corporation entwickelt. Hier sind einige Merkmale von LMDB:

    Speicherung beliebiger Schlüssel/Datenpaare als Byte-Arrays
    Bereichsbasierte Suchfunktion
    Unterstützung für einen einzigen Schlüssel mit mehreren Datenelementen
    Fortgeschrittene Methoden zum Anhängen von Datensätzen am Ende der Datenbank, was zu einer drastischen Steigerung der Schreibleistung gegenüber anderen ähnlichen Speichern führt

5.5.2 Die Struktur eines Blocks

Die CryptoNote-Standards definieren Spezifikationen für die Speicherung und Abgrenzung von Daten innerhalb von Blöcken und in der Blockchain. Die Blockstruktur besteht aus drei Hauptkomponenten:

    Der Blockkopf
    Die Basistransaktion
    Eine Liste von Transaktionsidentifikatoren (Hashes der im Block verarbeiteten Transaktionen)


5.5.2.1 Der Blockkopf

Jeder Block beginnt mit einer Kopfzeile, die wichtige Metadaten enthält. Die "major_version" definiert die Regeln für das Parsen des Blockheaders, damit dieser korrekt interpretiert werden kann. Die "minor_version" definiert die Interpretationsdetails, die nicht mit dem Parsen des Hauptheaders zusammenhängen.

Selbst wenn die Minor-Version unbekannt ist, ist es immer sicher, den Block-Header einer bestimmten Major-Version zu parsen. Das Parsen des Blockheaders mit einer unbekannten Hauptversion ist riskant, da der Inhalt des Blockheaders fehlinterpretiert werden kann.
Feld Typ Inhalt
major_version varint Hauptversion des Blockheaders
minor_version varint Kleinere Version des Blockkopfes
timestamp varint Erstellungszeit des Blocks (UNIX-Zeitstempel)
prev_id hash Kennung des vorherigen Blocks
nonce 4 Bytes Ein beliebiger Wert, der im Netzwerk-Konsensalgorithmus verwendet wird
5.5.2.2 Basistransaktion

Jeder gültige Block enthält eine einzelne Basistransaktion, die ihre Coinbase-Belohnung an den Miner weiterleitet. Die Basistransaktion muss den Coin-Emissionsregeln entsprechen und das Feld Blockhöhe enthalten.
5.5.2.3 Liste der Transaktionsbezeichner
Feld Typ Inhalt
version varint Version des Transaktionsformats
unlock_time varint UNIX-Zeitstempel.
input_num varint Anzahl der Eingänge. Immer 1 für Basistransaktionen.
input_type byte Immer 0xff für Basistransaktionen
height varint Höhe des Blocks, der die Transaktion enthält
output_num varint Anzahl der Ausgänge
outputs array Auflistung der Ausgänge als Array

Auf die Basistransaktion folgt eine Liste von Transaktionsbezeichnern. Diese Bezeichner werden anhand des Keccak-Hashes des Transaktionskörpers berechnet. Die Liste beginnt mit der Anzahl der Bezeichner und wird gefolgt von den Bezeichnern selbst (wenn der Block nicht leer ist).
5.5.2.4 Berechnung des Blockbezeichners

Der Bezeichner eines Blocks wird durch Hashing der folgenden Daten mit Keccak-256 erzeugt:

    Größe des block_header
    block_header
    Merkle-Root-Hash
    Anzahl der Transaktionen (varint)

Der Merkle-Root-Hash "verbindet" die Transaktionen, auf die im Blockkörper verwiesen wird, mit dem Blockkopf: Sobald der Merkle-Root-Hash festgelegt ist, können die Transaktionen nicht mehr geändert werden. Dieses Sicherheitsmerkmal schützt die Blockchains vor Manipulationen oder rückwirkenden Änderungen.


5.5.3 Die Bergbauwirtschaft

Blockprämien und Gebühren wurden in den Kapiteln 2 und 4 konzeptionell erwähnt. Jetzt werden Sie mehr über die Komplexität von Blockgrößen, Belohnungen und die Beziehung zu Gebühren erfahren.
5.5.3.1 Coinbase-Belohnung für das Mining

Wie in Kapitel 4 beschrieben, werden alle Moneroj als Belohnungen an Miner für erfolgreich abgeschlossene Blöcke ausgezahlt. Die Höhe dieser coinbase-Zahlung hängt vom aktuellen Angebot (A) und der ursprünglichen Anzahl der atomaren Einheiten (S = 264 - 1) ab. Eine atomare Einheit ist die kleinste Teilung von Monero, die derzeit vom Netzwerk anerkannt wird (1x10-12 XMR)

Basisbelohnung = 2 * ((S - A) * 2-20 * 10-12)

Monero hat eine Tail-Emission, d.h. eine kleine feste Basisbelohnung, die auch dann noch gezahlt wird, wenn der größte Teil des Angebots abgebaut wurde. Die minimale Basisbelohnung von Monero beträgt 0,6 XMR pro Block, so dass Miner nie allein von Gebühren leben müssen.
5.5.3.2 Dynamische Blockgröße

Monero hat eine dynamische Blockgröße, die eine kontinuierliche Anpassung ermöglicht, wenn das Netzwerk wächst, im Gegensatz zu vielen Kryptowährungen, die eine statische (feste) Blockgröße verwenden. Zum Beispiel verursachte die anfängliche feste Blockgröße von 1 MB bei Bitcoin Skalierungsprobleme, da sie die Anzahl der Transaktionen, die in jeden Block aufgenommen werden konnten, begrenzte (und damit auch das gesamte Transaktionsvolumen für das Netzwerk). Im Jahr 2017 führte dieser Engpass zu Zeiten mit extrem hohen Gebühren und verzögerter Verarbeitung von Transaktionen. Es wurden verschiedene Lösungsvorschläge unterbreitet, was zu einer Zeit der kontroversen Debatte führte.

Um diese Probleme zu vermeiden, verwendet Monero einen dynamischen Blockgrößen-Mechanismus, der es den Minern ermöglicht, größere Blöcke zu verwenden, um den erhöhten Datenverkehr zu bewältigen. Wäre die Blockgröße jedoch völlig frei, könnte das Monero-Netzwerk für Spam-Angriffe anfällig sein, d. h. für viele kleine Transaktionen, die darauf abzielen, Netzwerk- und Speicherressourcen zu erschöpfen, indem sie die Blockchain zu schnell wachsen lassen.

Um ein übermäßiges Wachstum der Blöcke zu verhindern, enthält das Mining-Protokoll von Monero eine Straffunktion, die die Coinbase-Belohnung für zu große Blöcke verringert. Die ursprünglichen CryptoNote-Autoren haben diese Konsensregel eingeführt, um die Geschwindigkeit des Blockgrößenwachstums zu begrenzen und ein schnelles Aufblähen der Blockchain zu vermeiden.

Wenn ein Block mit einer Größe (B) geschürft wird, die größer ist als die mittlere Größe der letzten 100 Blöcke (MN), wird ein Teil der Basisbelohnung einbehalten, gemäß:

Penalty = BaseReward * ((B / MN) - 1)2

Die Schürfer erhalten die volle Belohnung für Blöcke bis zu einer Größe von 300 kB; bei allen größeren Blöcken setzt die Straffunktion ein. Die maximale Blockgröße beträgt 2* MN, wobei dann die gesamte Coinbase einbehalten wird.
5.5.3.3 Gebühren

Bei geringem Transaktionsvolumen und kleinen Blockgrößen werden die Schürfer mit der vollen Coinbase belohnt, und die Gebühren sind minimal.

Stellen Sie sich jedoch ein anderes Szenario vor: Was passiert, wenn die durchschnittliche Größe der letzten 100 Blöcke größer wird als die straffreie Blockgröße (300 kB)? Dann kommt der dynamische Gebührenalgorithmus ins Spiel!

Die Gebühren werden nach dem Gewicht der Transaktionen in kB berechnet. Größere ("schwerere") Transaktionen verursachen eine höhere Gebühr. Die dynamische Gebührenberechnung ist komplex und berücksichtigt mehrere Faktoren des Monero-Ökosystems sowie die Priorität der Transaktion (der Absender kann den Minern einen Anreiz bieten, eine dringende Transaktion schnell einzubinden, indem er eine höhere Gebühr verlangt). Die Gebühren, die notwendig sind, um in einem kommenden Block wettbewerbsfähig zu sein, werden wie folgt berechnet:

Gebühr pro kB = (R/R0) * (M0/M) * F0 * (60/300) * 4

    R ist die Grundvergütung
    R0 ist die Referenz-Basisvergütung (10 XMR)
    M ist die Blockgrößengrenze
    M0 ist die Mindestgrenze für die Blockgröße (300 kB)
    F0 ist 0,002 XMR
    60/300 ist der Anpassungsfaktor zur Berücksichtigung der Anhebung der straffreien Blockgrößengrenze (2017 von 60 kB auf 300 kB angepasst)
    4 ist der Anpassungsfaktor für den Standardgebührenmultiplikator (die niedrigste Gebührenstufe verwendet einen Multiplikator von x1 und eine Transaktion mit normaler Priorität verwendet x4)

Die Gebühren berücksichtigen also den Anstieg der mittleren Blockgröße im Vergleich zur Mindestblockgröße. Zum Beispiel reduziert eine Blockgröße von 600 kB (das Doppelte der Mindestgröße) die Gebühren um die Hälfte.

Im Idealfall würde ein Anstieg des Wechselkurses und der Nutzung von Monero zu einer Senkung der absoluten Gebühren (d. h. in Bezug auf XMR) führen. Dieser Gebührensenkungsmechanismus ist weniger effektiv bei extremen Preissteigerungen, die unverhältnismäßig größer sind als der Anstieg des Transaktionsvolumens (und damit der Blockgröße).

Der dynamische Gebührenalgorithmus ist so konzipiert, dass er funktioniert, wenn die mittlere Blockgröße konstant über 300 kB liegt. Das System soll zwar Preiserhöhungen berücksichtigen, aber die Nutzung korreliert nicht perfekt mit dem Preis und ist daher nur ein unvollkommener Ersatz.

5.5.4 Bulletproofs

Bulletproofs sind eine neue Funktion, die die Transaktionsgröße drastisch verringert, was wiederum die Gesamtgebühren pro Transaktion reduziert! Monero-Transaktionen waren bisher recht groß (normalerweise > 12 kB), daher waren Bulletproofs eine lang erwartete Verbesserung.

Die Datenschutzfunktionen von Monero erfordern mehrere komplexe "Tests" während der Transaktionsvalidierung, um Missbrauch und Spam zu verhindern. Dazu gehören die Überprüfung von maskierten Beträgen, die Überprüfung von Gebühren und die Bestätigung, dass keine doppelten Ausgaben getätigt werden.

Die meisten Entwickler sind schon auf "Überlauf"-Fehler gestoßen, wenn eine Operation einen Wert außerhalb des darstellbaren Bereichs erzeugt. Leider ist "unendlich" ein abstraktes Konzept für die Elektronik, die bei großen Zahlen auf viele Hindernisse stößt.

Da RingCT die Transaktionsbeträge verbirgt, sind komplizierte Berechnungen erforderlich, um zu überprüfen, ob die Ein- und Ausgänge richtig ausgeglichen sind. Die nützlichen algebraischen Eigenschaften von Commitments sind wertvoll, um maskierte Transaktionen zu ermöglichen, deren Gültigkeit von jedem Teilnehmer bestätigt werden kann.

Es muss jedoch auch sichergestellt werden, dass jeder Betrag ein positiver Wert ist, der keinen Überlauf verursacht. Hier kommen die Bereichsnachweise ins Spiel, die es jedem ermöglichen, zu überprüfen, ob eine Zusage einen Betrag innerhalb eines bestimmten Bereichs darstellt, ohne etwas anderes über ihren Wert zu verraten. Jeder Bereichsnachweis benötigte früher ca. 7 kB, so dass er den größten Teil der Transaktionsgröße ausmachte. Die meisten Transaktionen haben zwei Ausgaben (die Ziel- und die Änderungsadresse), die mindestens ~12 kB benötigen.

Bulletproofs verwenden einige clevere mathematische Tricks, um den Bereichsnachweis mit einem effizienteren Mechanismus zu konstruieren. Dadurch wird die Größe eines einzelnen Bereichsnachweises auf ~2 kB reduziert!

Vor der Einführung von Bulletproofs waren für Transaktionen mit mehreren Ausgaben mehrere separate Bereichsnachweise erforderlich. Folglich skalierte die Transaktionsgröße linear mit der Anzahl der Ausgaben (z. B. 1 Ausgabe = 7 kB, 2 Ausgaben = 14 kB). Bei Bulletproofs hingegen skaliert die Größe logarithmisch mit der Anzahl der Ausgänge (z. B. 1 Ausgang = 2 kB, 2 Ausgänge = 2,5 kB).

Durch die Verringerung der Größe jedes einzelnen Bereichsnachweises und die Möglichkeit, sie auf effizientere Weise zu kombinieren, verringern Bulletproofs die Transaktionsgröße und damit die Gebühren drastisch. Bulletproofs wurden mit dem Monero v0.13.0 Netzwerk-Upgrade im Oktober 2018 als Opt-in-Funktion aktiviert, die mit dem nächsten Upgrade obligatorisch wird.
5.6. Fungibilität

Wie Sie sehen können, verwendet Monero mehrere hochentwickelte Verschlüsselungsprotokolle, um sein Netzwerk zu sichern und die grundlegenden Prinzipien der Privatsphäre und Dezentralisierung einzuhalten. Mit Hilfe des Monero Research Labs und verschiedener Prüfstellen wird Monero weiterhin modernste Verschlüsselungstechnologien identifizieren und validieren, um die Technologie so schnell, sicher, privat und effizient wie möglich zu machen.

Eine der wichtigsten Eigenschaften von Geld ist die sogenannte Fungibilität. Fungibilität bedeutet, dass ein Wertgegenstand einem anderen Wertgegenstand in gleicher Höhe entspricht. Eine Unze Gold ist gleich eine Unze Gold. Oder in unserem Fall, ein Moneroj ist gleich ein Moneroj. Die von Monero verwendeten Verschlüsselungsprotokolle machen es fungibel und ermöglichen es ihm, sein Ziel zu erreichen, echtes, digitales Geld zu sein.

Kryptowährungen, die in ihrer Basisschicht transparent sind, verfügen nicht über diese Verschlüsselungsschichten und sind daher nicht fungibel. Eine Münze, die im Dark Net aufgespürt werden kann, ist verdorben, und Münzen, die neu geprägt oder von den Strafverfolgungsbehörden versteigert werden, können mit einem Aufschlag verkauft werden. Bei transparenten Kryptowährungen hat eine Münze also nicht denselben Wert wie eine andere Münze mit demselben Betrag. Sie sind nicht fungibel. Dies ist bei dem Ziel, digitales Geld zu sein, wirklich problematisch.

Abgesehen von der Aufrechterhaltung einer guten Sicherheit, Privatsphäre und Dezentralisierung durch Moneros ausgeklügelte Verschlüsselungsprotokolle, stellt es auch die Fungibilität sicher, eine wesentliche Komponente von gesundem Geld.
